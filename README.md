# graphql Demo

graphql demo for share with workmate


## GraphQL 一种用于API的查询语言

## 背景
    - 目前我们可能需要接入很多的APP版本，然后有很多用户他们是不更新APP版本的，
    或者是说他们有的还用着很老的手机，就不想更新，类似于QQ，现在的Nokia按键功能机都还能用QQ
    然后QQ是自己定义了一套自己的数据协议。然后我们现在argus 可能也需要接入很多的门户，或者提供给很多的APP接入
    然后提供一系列的功能，以及版本的更新啊，还有写一系列的文档。那我们现在怎么做呢？
    可能就是直接加功能就加接口，然后再更新一波接口文档，可能这就是我们目前的做法
    然后我们得写明描述信息某个字段代表什么，然后得告诉说某个字段必传，然后要传什么类型的数据
## graphql 是什么？为什么是graphql
    - GraphQL 一种用于 API 的查询语言
    - 使得客户端能够准确地获得它需要的数据，而且没有任何冗余
    - 也让 API 更容易地随着时间推移而演进
    - GraphQL并不直接提供后端存储的能力
    - 谁再用graphql --2018.5.22 github v4
    - Facebook
    - Twitter
## graphql 提供的能力
    -  - 请求你所要的数据不多不少，向你的 API 发出一个 GraphQL 请求就能准确获得你想要的数据，不多不少。
    - GraphQL 查询总是返回可预测的结果。使用 GraphQL 的应用可以工作得又快又稳，因为控制数据的是应用，而不是服务器。
    - 获取多个资源
只用一个请求
GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询。典型的 REST API 请求多个资源时得载入多个 URL，而 GraphQL 可以通过一次请求就获取你应用所需的所有数据。这样一来，即使是比较慢的移动网络连接下，使用 GraphQL 的应用也能表现得足够迅速。
    - 发送查询之前就能高亮潜在问题，高级代码智能提示。
    - API 演进GraphQL API 添加字段和类型而无需影响现有查询
    - query 用于查询数据，mutations用于变更数据，就类似于restful get请求都用于查询数据，然后post请求用于修改数据一样只是一个约定
    - 我们可以通过在调试窗口直接调试，然后做传参，然后类型校验，当然还可以定一部分变量。
    - 只定义了协议，就类似我没看看的IP协议的RFC文档一样，定义了一个标准，然后会有go python java等具体的实现，接下来我们要演示用的就是一个go的实现
    - GraphQL 自带一组默认标量类型。
```
    Int：有符号 32 位整数。
    Float：有符号双精度浮点值。
    String：UTF‐8 字符序列。
    Boolean：true 或者 false。
    ID：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。 
```
- 高级数据类型包括：Object、Interface、Union、Enum、Input Object、List、Non-Null 这里不做详述

## graphql 跟restful 相比有什么优缺点
    - 缺乏可拓展性。 一个刚开始简单的用户接口可能只返回少部分信息，例如用户名、头像等。随着API的不断发展，可能需要返回更多的信息，例如年龄、昵称、签名等。很多时候客户端只是需要其中的部分信息，但是接口依旧传输了所有的信息，这个情况增加了网络传输量，特别对于移动应用来说特别不友好，同时需要客户端自行提取需要的数据
    - 复杂的数据需求需要做多次API调用。 例如客户端要显示文章的内容，可能要调用文章接口、评论接口、用户信息接口。为构成对一个资源的完整视图，需要做多次单独调用，这样的数据获取方式非常不灵活
    - RESTful：服务端决定有哪些数据获取方式，客户端只能挑选使用，如果数据过于冗余也只能默默接收再对数据进行处理；而数据不能满足需求则需要请求更多的接口。

    - GraphQL ： 给客户端自主选择数据内容的能力，客户端完全自主决定获取信息的内容，服务端负责精确的返回目标数据
## go的实践
    - 类型系统
    
## 还存在的问题/golang的其它库
    - 查询性能,GraphQL查询的每个字段如果都有自己的resolve方法，可能导致一次查询操作对数据库跑了大量了query，数据库里一趟select+join就能完成的事情在这里看来会产生大量的数据库查询操作，虽然网络层面的请求数被优化了
    - 
## issues